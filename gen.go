// +build ignore

package main

import (
	"log"
	"os"
	"strings"

	"text/template"
)

func main() {
	w, err := os.Create("tables.go")
	if err != nil {
		log.Fatalln(err)
	}
	defer w.Close()
	if err := tpl.Execute(w, map[string]string{
		"isSpaceASCII": string(isSpaceASCII[:]),
		"toLowerASCII": string(toLowerASCII[:]),
		"toUpperASCII": string(toUpperASCII[:]),
		// "isNumberStart": string(isNumberStart[:]),
		"isNumberEnd": string(isNumberEnd[:]),
		"isDigit":     string(isDigit[:]),
		// "toValue":        string(toValue[:]),
		// "isNonZeroDigit": string(isNonZeroDigit[:]),
		"toHexDigit":    string(toHexDigit[:]),
		"toHex":         string(toHex[:]),
		"toNamedEscape": string(toNamedEscape[:]),
	}); err != nil {
		log.Fatalln(err)
	}
}

var (
	isSpaceASCII   = [255]byte{}
	toLowerASCII   = [255]byte{}
	toUpperASCII   = [255]byte{}
	isNumberStart  = [255]byte{}
	isNumberEnd    = [255]byte{}
	isDigit        = [255]byte{}
	isNonZeroDigit = [255]byte{}
	// toValue        = [255]byte{}
	toHexDigit    = [255]byte{}
	toHex         = [255]byte{}
	toNamedEscape = [255]byte{}
)

func init() {

	for i := 0; i < 255; i++ {
		toLowerASCII[i] = byte(i)
		toUpperASCII[i] = byte(i)
		toHexDigit[i] = 0xff
	}
	toNamedEscape['n'] = '\n'
	toNamedEscape['t'] = '\t'
	toNamedEscape['r'] = '\r'
	toNamedEscape['b'] = '\b'
	toNamedEscape['f'] = '\f'
	for i := 0; i < 10; i++ {
		toHex[i] = byte('0' + i)
	}
	for i := 10; i < 16; i++ {
		toHex[i] = byte('a' + i - 10)
	}
	for i := '0'; i <= '9'; i++ {
		isDigit[i] = 1
		isNonZeroDigit[i] = 1
		isNumberStart[i] = 1
		toHexDigit[i] = byte(i) - '0'
		// toValue[i] = '0'
	}
	for i := 'a'; i <= 'f'; i++ {
		toHexDigit[i] = 10 + byte(i) - 'a'
	}
	for i := 'A'; i <= 'F'; i++ {
		toHexDigit[i] = 10 + byte(i) - 'A'
	}
	isNumberEnd[','] = 1
	isNumberEnd['}'] = 1
	isNumberEnd[']'] = 1
	isNumberEnd[' '] = 1
	isNumberEnd['\t'] = 1
	isNumberEnd['\n'] = 1
	isNumberEnd['\r'] = 1
	isNonZeroDigit['0'] = 0
	isNumberStart['-'] = 1
	// toValue['-'] = '0'
	// toValue['t'] = 'b'
	// toValue['f'] = 'b'
	// toValue['['] = 'a'
	// toValue['{'] = 'o'
	// toValue['n'] = 'n'
	// toValue['"'] = 's'
	for i := 'a'; i <= 'z'; i++ {
		toLowerASCII[i] = byte(i)
	}
	for i := 'A'; i <= 'Z'; i++ {
		toUpperASCII[i] = byte(i)
	}
	isSpaceASCII[' '] = 1
	isSpaceASCII['\t'] = 1
	isSpaceASCII['\n'] = 1
	isSpaceASCII['\r'] = 1

}

const T = `// Code generated by go generate; DO NOT EDIT.
package njson

const (
{{- range $name, $table := .}}
	{{$name}} = {{printf "%q" $table}}
{{- end}}
)

{{- range $name, $table := .}}
{{- $c := index $name 0}}
{{- if eq 't' $c }}
func {{$name|title}}(c byte) byte {
	return {{$name}}[c]
}
{{- else if eq 'i' $c }}
func {{$name|title}}(c byte) bool {
	return {{$name}}[c] == 1
}
{{- end}}
{{- end}}

`

var (
	funcs = template.FuncMap{
		"trimprefix": strings.TrimPrefix,
		"title":      strings.Title,
	}
	tpl = template.Must(template.New("").Funcs(funcs).Parse(T))
)
