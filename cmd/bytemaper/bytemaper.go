package main

import (
	"flag"
	"log"
	"os"
	"strings"
	"unicode"
	"unicode/utf8"

	"text/template"
)

var (
	pkgName  = flag.String("pkg", "main", "Package name to use")
	fileName = flag.String("w", "", "Write output to file")
	prefix   = flag.String("prefix", "bytemap", "Var name prefix")
)

func trIs(fn func(rune) bool) func(byte) byte {
	return func(b byte) byte {
		if fn(rune(b)) {
			return 1
		}
		return 0
	}
}
func trTo(fn func(rune) rune) func(byte) byte {
	return func(b byte) byte {
		r := fn(rune(b))
		if utf8.RuneLen(r) == 1 {
			return byte(r)
		}
		return 0
	}
}

func nameOrDefault(name, defaultName string) string {
	if name == "" {
		name = defaultName
	}
	return name
}

func toHex(c byte) byte {
	switch {
	case 0 <= c && c <= 9:
		return c + '0'
	case 10 <= c && c <= 15:
		return c + 'A' - 10
	default:
		return 0xff
	}
}

func fromHex(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'z':
		return 10 + c - 'a'
	case 'A' <= c && c <= 'Z':
		return 10 + c - 'A'
	default:
		return 0xff
	}
}
func main() {
	flag.Parse()
	w := os.Stdout
	if *fileName != "" {
		f, err := os.Create(*fileName)
		if err != nil {
			log.Fatalln("Failed to open file for writing", err)
		}
		w = f
	}
	masks := map[string]string{}
	var tr func(b byte) byte
	for _, arg := range flag.Args() {
		varName := ""
		if i := strings.IndexByte(arg, ':'); i != -1 {
			varName = arg[:i]
			arg = arg[i+1:]
		}
		switch arg {
		case "ToHex":
			tr = toHex
			varName = nameOrDefault(varName, arg)
		case "FromHex":
			tr = fromHex
			varName = nameOrDefault(varName, arg)
		case "IsControl":
			tr = trIs(unicode.IsControl)
			varName = nameOrDefault(varName, arg)
		case "IsPunct":
			tr = trIs(unicode.IsPunct)
			varName = nameOrDefault(varName, arg)
		case "IsDigit":
			tr = trIs(unicode.IsDigit)
			varName = nameOrDefault(varName, arg)
		case "IsSpace":
			tr = trIs(unicode.IsSpace)
			varName = nameOrDefault(varName, arg)
		case "IsPrint":
			tr = trIs(unicode.IsPrint)
			varName = nameOrDefault(varName, arg)
		case "ToLower":
			tr = trTo(unicode.ToLower)
			varName = nameOrDefault(varName, arg)
		case "ToUpper":
			tr = trTo(unicode.ToUpper)
			varName = nameOrDefault(varName, arg)
		case "ToTitle":
			tr = trTo(unicode.ToTitle)
			varName = nameOrDefault(varName, arg)
		default:
			if varName == "" {
				log.Fatalf("Invalid arg %q\n", arg)
			}
			tr = func(b byte) byte {
				if strings.IndexByte(arg, b) != -1 {
					return 1
				}
				return 0
			}

		}
		mask := make([]byte, 255)
		for i := 0; i < 255; i++ {
			mask[i] = tr(byte(i))
		}
		masks[*prefix+varName] = string(mask)
	}
	if err := tpl.Execute(w, map[string]interface{}{
		"PkgName": *pkgName,
		"Maps":    masks,
	}); err != nil {
		log.Fatalln("Failed to write file", err)
	}

}

var tpl = template.Must(template.New("masks").Parse(`// Code generated by bytemaper; DO NOT EDIT.
package {{.PkgName}}

const (
{{- range $name, $map := .Maps }}
	{{$name}} = {{ printf "%q" $map }}
{{- end }}
)
`))
