package generator

/*
Package generator is a code generator for njson.Unmarsaler

It parses a package dir and can generate (t *T)UnmarshalNodeJSON(*njson.Node) error methods.
*/

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/alxarch/meta"
)

// TODO: handle json.Unmarshaler
// TODO: handle njson.Unmarshaler
// TODO: handle encoding.TextUnmarshaler
// TODO: handle flag combinations (ie if tag key is not json don't use UnmarshalJSON)

// Generator is a source code generator for njson unmarshal methods.
type Generator struct {
	*meta.Package
	options
	test    bool
	buffer  bytes.Buffer
	imports map[string]*types.Package
}

type typeError struct {
	typ types.Type
}

func (e typeError) Error() string {
	return fmt.Sprintf("Unsupported type %s %#v", e.typ, e.typ)
}

// AllStructs returns all structs from the package.
func (g *Generator) AllStructs() (all []string) {
	types := g.Package.DefinedTypes(meta.IsStruct)
	for _, typ := range types {
		all = append(all, g.TypeString(typ))
	}
	return
}

func newGenerator(path, targetPkg string, filter func(os.FileInfo) bool) (g *Generator, err error) {
	mode := parser.ParseComments | parser.DeclarationErrors
	p, err := meta.ParsePackage(targetPkg, path, filter, mode, func(f *ast.File) bool {
		return !IsGeneratedByNJSON(f)
	})
	if err != nil {
		return
	}
	g = new(Generator)
	g.Package = p
	g.logger = log.New(ioutil.Discard, "", 0)
	return
}

// New creates a new Generator for a package named targetPkg and parses the specified path.
func New(path string, targetPkg string, options ...Option) (*Generator, error) {
	var filter func(os.FileInfo) bool
	if !strings.HasSuffix(targetPkg, "_test") {
		filter = meta.IgnoreTestFiles
	}
	g, err := newGenerator(path, targetPkg, filter)
	if err != nil {
		return nil, err
	}
	for _, opt := range options {
		opt(g)
	}
	return g, nil
}

// Filename returns the filename to write output.
func (g *Generator) Filename() (name string) {
	name = g.Name()
	if strings.HasSuffix(name, "_test") {
		name = strings.TrimSuffix(name, "_test")
		name = name + "_njson_test.go"
		return
	}
	name = name + "_njson.go"
	return

}

// Reset resets the generator to start a new file.
func (g *Generator) Reset() {
	g.buffer.Reset()
	g.imports = nil
}

// Import adds packages to import in the generated file
func (g *Generator) Import(imports ...*types.Package) {
	if len(imports) == 0 {
		return
	}
	if g.imports == nil {
		g.imports = make(map[string]*types.Package, len(imports))
	}
	for _, pkg := range imports {
		if pkg.Path() != g.Package.Path() {
			g.imports[pkg.Path()] = pkg
		}
	}
	return
}

// DumpTo writes the generated file without checking and formatting.
func (g *Generator) DumpTo(w io.Writer) error {
	if _, err := w.Write([]byte(g.Header())); err != nil {
		return err
	}
	if _, err := g.buffer.WriteTo(w); err != nil {
		return err
	}
	return nil
}

// PrintTo writes the generated file after checking and formatting.
func (g *Generator) PrintTo(w io.Writer) error {
	fset := token.NewFileSet()
	buf := new(bytes.Buffer)
	buf.WriteString(g.Header())
	g.buffer.WriteTo(buf)
	filename := g.Filename()
	astFile, err := parser.ParseFile(fset, filename, buf.Bytes(), parser.ParseComments)
	if err != nil {
		return err
	}
	ast.SortImports(fset, astFile)
	return format.Node(w, fset, astFile)
}

const (
	njsonPkgPath = "github.com/alxarch/njson"
	njsonPkgName = "njson"
)

var (
	njsonPkg   = types.NewPackage(njsonPkgPath, njsonPkgName)
	strjsonPkg = types.NewPackage(njsonPkgPath+"/strjson", "strjson")
	// njsonutilPkg = types.NewPackage(njsonPkgPath+"/njsonutil", "njsonutil")
	// testingPkg   = types.NewPackage("testing", "testing")
	// reflectPkg   = types.NewPackage("reflect", "reflect")
	jsonPkg = types.NewPackage("encoding/json", "json")
	// fmtPkg       = types.NewPackage("fmt", "fmt")
	// stringsPkg   = types.NewPackage("strings", "strings")
	strconvPkg = types.NewPackage("strconv", "strconv")
)

const (
	headerComment = `// Code generated by njson on %s; DO NOT EDIT.`
)

func IsGeneratedByNJSON(f *ast.File) bool {
	return len(f.Comments) > 0 && strings.HasPrefix(f.Comments[0].Text(), "Code generated by njson")
}

// Header returns the header code for the generated file.
func (g *Generator) Header() string {
	h := []string{}
	now := time.Now().In(time.UTC)
	ts := now.Format(time.RFC1123)
	h = append(h, fmt.Sprintf(headerComment, ts))
	h = append(h, fmt.Sprintf("package %s", g.Name()))

	for path, pkg := range g.imports {
		if filepath.Base(path) == pkg.Name() {
			h = append(h, fmt.Sprintf("import %q", path))
		} else {
			h = append(h, fmt.Sprintf("import %s %q", pkg.Name(), path))
		}
	}
	return strings.Join(h, "\n")

}
