//+build ignore

package main

import (
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"reflect"

	"text/template"

	"github.com/iancoleman/strcase"
)

func main() {
	fset := token.NewFileSet()
	data := `
package main

import _ "github.com/icrowley/fake"
`
	f, err := parser.ParseFile(fset, "fake.go", data, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	files := []*ast.File{f}
	config := types.Config{
		IgnoreFuncBodies: true,
		Importer:         importer.Default(),
	}
	info := types.Info{
		Defs: make(map[*ast.Ident]types.Object),
	}
	pkg, err := config.Check("fake.go", fset, files, &info)
	if err != nil {
		log.Fatal(err)
	}
	imports := pkg.Imports()
	var scope *types.Scope
	for i := range imports {
		pkg := imports[i]
		if pkg.Name() == "fake" {
			scope = pkg.Scope()
			break
		}
	}
	if scope == nil {
		log.Fatal("Package scope not found.")
	}
	ignore := map[string]bool{
		"UseExternalData": true,
		"GetLangs":        true,
		"SetLangs":        true,
		"Seed":            true,
	}
	methods := map[string]interface{}{}
	for _, name := range scope.Names() {
		obj := scope.Lookup(name)
		if !obj.Exported() {
			continue
		}
		if ignore[obj.Name()] {
			continue
		}
		typ := obj.Type()
		if typ == nil {
			continue
		}
		sig, ok := typ.(*types.Signature)
		if !ok {
			continue
		}
		params := sig.Params()
		args := []*types.Var{}
		for i := 0; i < params.Len(); i++ {
			args = append(args, params.At(i))
		}
		methods[obj.Name()] = args

	}
	w, err := os.Create("template.go")
	if err != nil {
		log.Fatal(err)
	}

	defer w.Close()
	if err := tpl.Execute(w, methods); err != nil {
		log.Fatal(err)
	}

}

var (
	funcs = template.FuncMap{
		"snake": strcase.ToSnake,
		"arglist": func(args reflect.Value) (out string) {
			for i := 0; i < args.Len(); i++ {
				if i > 0 {
					out += ", "
				}
				out += "arg%d"
			}
			return
		},
	}
	tpl = template.Must(template.New("fake.go").Funcs(funcs).Parse(`// Code generated by go generate; DO NOT EDIT.
package fake

import "errors"

func TemplateFunc(fn string, args ...interface{}) (interface{}, error) {
	switch fn {
	default:
		return nil, errors.New("Invalid method name: " + fn)
	{{- range $fn, $args := . }}
	case {{ $fn | snake }}:
	{{- if $args }}
		if len(args) != {{ len $args }} {
			return nil, errors.New("Invalid number of arguments for {{ $fn }}" )
		}
		{{- range $i, $a := $args }}
		arg{{ $i }}, ok := args[{{ printf "%d" $i }}].({{ $a.Type  }})
		if !ok {
			return nil, errors.New("{{ printf "Invalid argument %q for %s" $a.Name $fn }}" )
		}
		{{- end }}
		return {{ $fn }}({{ $args | arglist }}), nil
	{{- else }}
		return {{ $fn }}(), nil
	{{- end }}
	{{- end }}
	}
}

`))
)
